<p align="center">
  <img src="./logo.png" width="550"/>
</p>

<p align="center">
  <a title="GoDoc" href="https://godoc.org/github.com/umarcor/run/lib"><img src="https://img.shields.io/badge/godoc-reference-5272B4.svg?longCache=true&style=flat-square&logo=go&logoColor=fff"></a><!--
  -->
  <a title="Releases" href="https://github.com/umarcor/run/releases"><img src="https://img.shields.io/github/commits-since/umarcor/run/latest.svg?longCache=true&style=flat-square"></a>
</p>

---

`run` is a task execution automation package that analyses complex dependency graphs ([multitree](https://en.wikipedia.org/wiki/Multitree) [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph)), generates filtered subgraphs for each target and provides ordered lists of tasks through [topological sorting](https://en.wikipedia.org/wiki/Topological_sorting).

`run` is neither a replacement nor a wrapper for [Make](https://en.wikipedia.org/wiki/Make_(software)), instead it is a complement. The main use case is the combination of multiple build steps, each with a different tool which has it's own build system (be it `make`, `cmake`, `go build`, etc.), and probably involving parameters provided through JSON files, CLI arguments and/or environment variables.

`run` is meant to be used as a library in other [golang](https://golang.org/) projects, such as CLI tools or web services. This allows to make the best of other libraries to process data and handle parallel (concurrent) execution seamlessly. Nonetheless, an example CLI tool based on [spf13/cobra](https://github.com/spf13/cobrahttps://github.com/spf13/viper/) and [spf13/viper](https://github.com/spf13/viper/) is provided as a reference.

`run` is built on top of [gonum](https://www.gonum.org/). Precisely, types, interfaces and functions defined in [gonum/graph](https://github.com/gonum/gonum/tree/master/graph) ([godoc.org/gonum.org/v1/gonum/graph](https://godoc.org/gonum.org/v1/gonum/graph)) are used to manipulate graphs. Therefore, `run` relies on the list of input formats supported by the package. In the examples, [Graphviz](https://www.graphviz.org/)'s [DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) language is used, which is a widespread output format supported by many tools. For example, [lindenb/makefile2graph](https://github.com/lindenb/makefile2graph) allows to analyse makefiles, and [kisielk/godepgraph](https://github.com/kisielk/godepgraph) generates *a dependency graph of Go packages*.

# ToDo for v1.0.0

- We want to be able to retrieve the topological order of a subset of nodes in one of the subgraphs. We are evaluating three approaches:
  - Retrieve the topological order of the subgraph and then remove the items that are to be ignored.
  - Generate a subsubgraph from the subgraph and retrieve the topological order.
  - We feel that we will need both: first generate a subsubgraph and then optionally remove some items from the topological order.
- Propose `gonum/graph/dep`.
- Support minimal web GUI to show subgraphs, subsubgraphs and task lists.
- Provide basic example implementation of 'Exec'.
- Allow to decide whether a target needs to be regenerated by comparing file modification times.
- Merge graphs from different sources which might share some nodes and edges.
- Dry run mode
- Go's template engine
- ignore certain tasks in a list

---

# Usage

The main input is a large complex graph where developers put the dependencies of their multiple workflows. Some of them are cross-related, some are independent dependency chains. This can be provided as a `graphviz` `dot` file:

```
strict digraph {
// Node definitions.
A [label="yellow"];
B [label="green"];
C [label="red"];
D [label="blue"];
E [label="magenta"];
F [label="purple"];
// Edge definitions.
A -> B;
A -> C -> E -> F;
C -> D;
B -> F;
B -> E;
}
```

## Pre-processing

A subgraph for target `F` is generated, which does not include `D`, because it is an unrelated dependency. This is saved to `subgraph_F.dot`. Another subgraph, `subgraph_D.dot` is generated coherently.

> NOTE: the subgraphs can be shown in a web frontend, so the user can select to visualize all the dependecies or to choose a single target and show the corresponding subgraph.

## List

A user asks *"I will execute F in the end, but for now I want to know which steps do I need to execute in order to solve all the dependencies for E"*.

The response is `A -> C -> E`, because `B` is a dependency of `F` but not of `E`.

## Exec

The user provides the sources for each task (node) and the list of tasks is executed in order.

> TODO How is the logic of each task defined?
> - https://github.com/go-task/task

# References

- [gonum](https://www.gonum.org)
  - [godoc.org/gonum.org/v1/gonum](https://godoc.org/gonum.org/v1/gonum)
  - [gonum/gonum#910](https://github.com/gonum/gonum/issues/910)
    - [Preserving labels when marshaling a dot graph](https://groups.google.com/forum/#!topic/gonum-dev/xupu8gEmuIs)
    - [godoc.org/github.com/kortschak/graphprac](https://godoc.org/github.com/kortschak/graphprac)
- [semver.org](https://semver.org)
- [keepachangelog.com](https://keepachangelog.com)

---

The motivation that triggered the development of `run` is very similar to the context described in [dnaeon.github.io/graphs-and-clojure](http://dnaeon.github.io/graphs-and-clojure/):

> Within our organization we have different sub-teams, which manage different components of the infrastructure. (...) Each of these teams have different preference and experience when it comes to the Configuration Management systems that they use in order to build and automate stuff. (...)
>
> This led us to maintain desired configuration data in different configuration formats, so that they can be consumed by their respective Configuration Management system. Needless to say we ended up with lots of data duplication and fragmentation within the different teams.
>
> For example almost everyone kept a version of the organization NTP servers that we have been using, and this can become an issue whenever you need to update that list, because it's not easy to keep track or know what or where to look at for all the CM systems that we use - and they are ranging from Puppet, Ansible, Terraform, etc. and even our own internal build and deploy system.
>
> In order to address these issues, we have decided to roll out our own system which can provide all the different teams with a centralized solution for configuration data, which can be consumed by all the different CM systems that we use.